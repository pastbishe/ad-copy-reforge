// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { handleNetworkError, isRetryableError } from '@/lib/networkUtils';

const SUPABASE_URL = "https://ticugdxpzglbpymvfnyj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRpY3VnZHhwemdsYnB5bXZmbnlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY3MjEyMDksImV4cCI6MjA3MjI5NzIwOX0.pGdJS4Ql5ieOahI0InSMGv1p6sFGGcooUIAvPW_D6K8";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    fetch: async (url, options = {}) => {
      // Создаем AbortController для таймаута
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 секунд
      
      try {
        // Объединяем сигналы, если они уже есть
        const signal = options.signal 
          ? (() => {
              const combinedController = new AbortController();
              const abort = () => combinedController.abort();
              controller.signal.addEventListener('abort', abort);
              if (options.signal) {
                options.signal.addEventListener('abort', abort);
              }
              return combinedController.signal;
            })()
          : controller.signal;
        
        // Убеждаемся, что заголовки правильно установлены для Supabase PostgREST
        const headers = options.headers 
          ? (options.headers instanceof Headers 
              ? new Headers(options.headers) 
              : new Headers(options.headers as Record<string, string>))
          : new Headers();
        
        // Если заголовок Accept не установлен, устанавливаем его для Supabase
        if (!headers.has('Accept')) {
          headers.set('Accept', 'application/json');
        }
        
        // Убеждаемся, что Content-Type установлен для POST/PATCH/DELETE запросов
        if ((options.method === 'POST' || options.method === 'PATCH' || options.method === 'DELETE') 
            && !headers.has('Content-Type') && options.body) {
          headers.set('Content-Type', 'application/json');
        }
        
        const response = await fetch(url, {
          ...options,
          headers,
          signal,
        });
        
        clearTimeout(timeoutId);
        return response;
      } catch (error: any) {
        clearTimeout(timeoutId);
        // Обрабатываем сетевые ошибки
        const { message, isRetryable } = handleNetworkError(error);
        
        // Если ошибка может быть повторена и это не последняя попытка, пробуем еще раз
        if (isRetryable && !error.retried) {
          // Добавляем флаг, чтобы не зациклиться
          error.retried = true;
          
          // Ждем немного перед повтором
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Пробуем еще раз
          try {
            return await fetch(url, options);
          } catch (retryError) {
            // Если повтор тоже не удался, выбрасываем ошибку с понятным сообщением
            const networkError: any = new Error(message);
            networkError.originalError = retryError;
            networkError.isNetworkError = true;
            throw networkError;
          }
        }
        
        // Если ошибка не может быть повторена, выбрасываем её с понятным сообщением
        const networkError: any = new Error(message);
        networkError.originalError = error;
        networkError.isNetworkError = true;
        throw networkError;
      }
    },
  },
});

/**
 * Обертка для Supabase запросов с улучшенной обработкой ошибок
 */
export async function safeSupabaseQuery<T>(
  queryFn: () => Promise<{ data: T | null; error: any }>
): Promise<{ data: T | null; error: any; userMessage?: string }> {
  try {
    const result = await queryFn();
    
    if (result.error) {
      const { message, isRetryable } = handleNetworkError(result.error);
      
      return {
        ...result,
        error: {
          ...result.error,
          userMessage: message,
          isRetryable,
        },
        userMessage: message,
      };
    }
    
    return result;
  } catch (error: any) {
    const { message } = handleNetworkError(error);
    
    return {
      data: null,
      error: {
        message: error.message || message,
        userMessage: message,
        isNetworkError: true,
      },
      userMessage: message,
    };
  }
}